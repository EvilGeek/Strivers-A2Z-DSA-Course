## âœ… Step 1: Learn the basics
### ğŸ”¸ Substep 1: Things to Know in C++/Java/Python or any language
- ğŸ”¹ User Input / Output
- ğŸ”¹ Data Types
- ğŸ”¹ If Else statements
- ğŸ”¹ Switch Statement
- ğŸ”¹ What are arrays, strings?
- ğŸ”¹ For loops
- ğŸ”¹ While loops
- ğŸ”¹ Functions (Pass by Reference and Value)
- ğŸ”¹ Time Complexity [Learn Basics, and then analyse in next Steps]
### ğŸ”¸ Substep 2: Build-up Logical Thinking
- ğŸ”¹ Patterns
### ğŸ”¸ Substep 3: Learn STL/Java-Collections or similar thing in your
            language
- ğŸ”¹ C++ STL
- ğŸ”¹ Java Collections
### ğŸ”¸ Substep 4: Know Basic Maths
- ğŸ”¹ Count Digits
- ğŸ”¹ Reverse a Number
- ğŸ”¹ Check Palindrome
- ğŸ”¹ GCD Or HCF
- ğŸ”¹ Armstrong Numbers
- ğŸ”¹ Print all Divisors
- ğŸ”¹ Check for Prime
### ğŸ”¸ Substep 5: Learn Basic Recursion
- ğŸ”¹ Understand recursion by print something N times
- ğŸ”¹ Print name N times using recursion
- ğŸ”¹ Print 1 to N using recursion
- ğŸ”¹ Print N to 1 using recursion
- ğŸ”¹ Sum of first N numbers
- ğŸ”¹ Factorial of N numbers
- ğŸ”¹ Reverse an array
- ğŸ”¹ Check if a string is palindrome or not
- ğŸ”¹ Fibonacci Number
### ğŸ”¸ Substep 6: Learn Basic Hashing
- ğŸ”¹ Hashing Theory
- ğŸ”¹ Counting frequencies of array elements
- ğŸ”¹ Find the highest/lowest frequency element

---
## âœ… Step 2: Learn Important Sorting Techniques
### ğŸ”¸ Substep 1: Sorting-I
- ğŸ”¹ Selection Sort
- ğŸ”¹ Bubble Sort
- ğŸ”¹ Insertion Sort
### ğŸ”¸ Substep 2: Sorting-II
- ğŸ”¹ Merge Sort
- ğŸ”¹ Recursive Bubble Sort
- ğŸ”¹ Recursive Insertion Sort
- ğŸ”¹ Quick Sort

---
## âœ… Step 3: Solve Problems on Arrays [Easy -> Medium -> Hard]
### ğŸ”¸ Substep 1: Easy
- ğŸ”¹ Largest Element in an Array
- ğŸ”¹ Second Largest Element in an Array without sorting
- ğŸ”¹ Check if the array is sorted
- ğŸ”¹ Remove duplicates from Sorted array
- ğŸ”¹ Left Rotate an array by one place
- ğŸ”¹ Left rotate an array by D places
- ğŸ”¹ Move Zeros to end
- ğŸ”¹ Linear Search
- ğŸ”¹ Find the Union
- ğŸ”¹ Find missing number in an array
- ğŸ”¹ Maximum Consecutive Ones
- ğŸ”¹ Find the number that appears once, and other numbers twice.
- ğŸ”¹ Longest subarray with given sum K(positives)
- ğŸ”¹ Longest subarray with sum K (Positives + Negatives)
### ğŸ”¸ Substep 2: Medium
- ğŸ”¹ 2Sum Problem
- ğŸ”¹ Sort an array of 0's 1's and 2's
- ğŸ”¹ Majority Element (>n/2 times)
- ğŸ”¹ Kadane's Algorithm, maximum subarray sum
- ğŸ”¹ Print subarray with maximum subarray sum (extended version of above problem)
- ğŸ”¹ Stock Buy and Sell
- ğŸ”¹ Rearrange the array in alternating positive and negative items
- ğŸ”¹ Next Permutation
- ğŸ”¹ Leaders in an Array problem
- ğŸ”¹ Longest Consecutive Sequence in an Array
- ğŸ”¹ Set Matrix Zeros
- ğŸ”¹ Rotate Matrix by 90 degrees
- ğŸ”¹ Print the matrix in spiral manner
- ğŸ”¹ Count subarrays with given sum
### ğŸ”¸ Substep 3: Hard
- ğŸ”¹ Pascal's Triangle
- ğŸ”¹ Majority Element (n/3 times)
- ğŸ”¹ 3-Sum Problem
- ğŸ”¹ 4-Sum Problem
- ğŸ”¹ Largest Subarray with 0 Sum
- ğŸ”¹ Count number of subarrays with given xor K
- ğŸ”¹ Merge Overlapping Subintervals
- ğŸ”¹ Merge two sorted arrays without extra space
- ğŸ”¹ Find the repeating and missing number
- ğŸ”¹ Count Inversions
- ğŸ”¹ Reverse Pairs
- ğŸ”¹ Maximum Product Subarray

---
## âœ… Step 4: Binary Search [1D, 2D Arrays, Search Space]
### ğŸ”¸ Substep 1: BS on 1D Arrays
- ğŸ”¹ Binary Search to find X in sorted array
- ğŸ”¹ Implement Lower Bound
- ğŸ”¹ Implement Upper Bound
- ğŸ”¹ Search Insert Position
- ğŸ”¹ Floor/Ceil in Sorted Array
- ğŸ”¹ Find the first or last occurrence of a given number in a sorted array
- ğŸ”¹ Count occurrences of a number in a sorted array with duplicates
- ğŸ”¹ Search in Rotated Sorted Array I
- ğŸ”¹ Search in Rotated Sorted Array II
- ğŸ”¹ Find minimum in Rotated Sorted Array
- ğŸ”¹ Find out how many times has an array been rotated
- ğŸ”¹ Single element in a Sorted Array
- ğŸ”¹ Find peak element
### ğŸ”¸ Substep 2: BS on Answers
- ğŸ”¹ Find square root of a number in log n
- ğŸ”¹ Find the Nth root of a number using binary search
- ğŸ”¹ Koko Eating Bananas
- ğŸ”¹ Minimum days to make M bouquets
- ğŸ”¹ Find the smallest Divisor
- ğŸ”¹ Capacity to Ship Packages within D Days
- ğŸ”¹ Kth Missing Positive Number
- ğŸ”¹ Aggressive Cows
- ğŸ”¹ Book Allocation Problem
- ğŸ”¹ Split array - Largest Sum
- ğŸ”¹ Painter's partition
- ğŸ”¹ Minimize Max Distance to Gas Station
- ğŸ”¹ Median of 2 sorted arrays
- ğŸ”¹ Kth element of 2 sorted arrays
### ğŸ”¸ Substep 3: BS on 2D Arrays
- ğŸ”¹ Find the row with maximum number of 1's
- ğŸ”¹ Search in a 2 D matrix
- ğŸ”¹ Search in a row and column wise sorted matrix
- ğŸ”¹ Find Peak Element (2D Matrix)
- ğŸ”¹ Matrix Median

---
## âœ… Step 5: Strings [Basic and Medium]
### ğŸ”¸ Substep 1: Basic and Easy String Problems
- ğŸ”¹ Remove outermost Paranthesis
- ğŸ”¹ Reverse words in a given string / Palindrome Check
- ğŸ”¹ Largest odd number in a string
- ğŸ”¹ Longest Common Prefix
- ğŸ”¹ Isomorphic String
- ğŸ”¹ check whether one string is a rotation of another
- ğŸ”¹ Check if two strings are anagram of each other
### ğŸ”¸ Substep 2: Medium String Problems
- ğŸ”¹ Sort Characters by frequency
- ğŸ”¹ Maximum Nesting Depth of Paranthesis
- ğŸ”¹ Roman Number to Integer and vice versa
- ğŸ”¹ Implement Atoi
- ğŸ”¹ Count Number of Substrings
- ğŸ”¹ Longest Palindromic Substring[Do it without DP]
- ğŸ”¹ Sum of Beauty of all substring
- ğŸ”¹ Reverse Every Word in A String

---
## âœ… Step 6: Learn LinkedList [Single LL, Double LL, Medium, Hard Problems]
### ğŸ”¸ Substep 1: Learn 1D LinkedList
- ğŸ”¹ Introduction to LinkedList, learn about struct, and how is node represented
- ğŸ”¹ Inserting a node in LinkedList
- ğŸ”¹ Deleting a node in LinkedList
- ğŸ”¹ Find the length of the linkedlist [learn traversal]
- ğŸ”¹ Search an element in the LL
### ğŸ”¸ Substep 2: Learn Doubly LinkedList
- ğŸ”¹ Introduction to DLL, learn about struct, and how is node represented
- ğŸ”¹ Insert a node in DLL
- ğŸ”¹ Delete a node in DLL
- ğŸ”¹ Reverse a DLL
### ğŸ”¸ Substep 3: Medium Problems of LL
- ğŸ”¹ Middle of a LinkedList [TortoiseHare Method]
- ğŸ”¹ Reverse a LinkedList [Iterative]
- ğŸ”¹ Reverse a LL [Recursive]
- ğŸ”¹ Detect a loop in LL
- ğŸ”¹ Find the starting point in LL
- ğŸ”¹ Length of Loop in LL
- ğŸ”¹ Check if LL is palindrome or not
- ğŸ”¹ Segrregate odd and even nodes in LL
- ğŸ”¹ Remove Nth node from the back of the LL
- ğŸ”¹ Delete the middle node of LL
- ğŸ”¹ Sort LL
- ğŸ”¹ Sort a LL of 0's 1's and 2's by changing links
- ğŸ”¹ Find the intersection point of Y LL
- ğŸ”¹ Add 1 to a number represented by LL
- ğŸ”¹ Add 2 numbers in LL
### ğŸ”¸ Substep 4: Medium Problems of DLL
- ğŸ”¹ Delete all occurrences of a key in DLL
- ğŸ”¹ Find pairs with given sum in DLL
- ğŸ”¹ Remove duplicates from sorted DLL
### ğŸ”¸ Substep 5: Hard Problems of LL
- ğŸ”¹ Reverse LL in group of given size K
- ğŸ”¹ Rotate a LL
- ğŸ”¹ Flattening of LL
- ğŸ”¹ Clone a Linked List with random and next pointer

---
## âœ… Step 7: Recursion [PatternWise]
### ğŸ”¸ Substep 1: Get a Strong Hold
- ğŸ”¹ Recursive Implementation of atoi()
- ğŸ”¹ Pow(x, n)
- ğŸ”¹ Count Good numbers
- ğŸ”¹ Sort a stack using recursion
- ğŸ”¹ Reverse a stack using recursion
### ğŸ”¸ Substep 2: Subsequences Pattern
- ğŸ”¹ Generate all binary strings
- ğŸ”¹ Generate Paranthesis
- ğŸ”¹ Print all subsequences/Power Set
- ğŸ”¹ Learn All Patterns of Subsequences (Theory)
- ğŸ”¹ Count all subsequences with sum K
- ğŸ”¹ Check if there exists a subsequence with sum K
- ğŸ”¹ Combination Sum
- ğŸ”¹ Combination Sum-II
- ğŸ”¹ Subset Sum-I
- ğŸ”¹ Subset Sum-II
- ğŸ”¹ Combination Sum - III
- ğŸ”¹ Letter Combinations of a Phone number
### ğŸ”¸ Substep 3: Trying out all Combos / Hard
- ğŸ”¹ Palindrome Partitioning
- ğŸ”¹ Word Search
- ğŸ”¹ N Queen
- ğŸ”¹ Rat in a Maze
- ğŸ”¹ Word Break
- ğŸ”¹ M Coloring Problem
- ğŸ”¹ Sudoko Solver
- ğŸ”¹ Expression Add Operators

---
## âœ… Step 8: Bit Manipulation [Concepts & Problems]
### ğŸ”¸ Substep 1: Learn Bit Manipulation
- ğŸ”¹ Introduction to Bit Manipulation [Theory]
- ğŸ”¹ Check if the i-th bit is set or not
- ğŸ”¹ Check if a number is odd or not
- ğŸ”¹ Check if a number is power of 2 or not
- ğŸ”¹ Count the number of set bits
- ğŸ”¹ Set/Unset the rightmost unset bit
- ğŸ”¹ Swap two numbers
- ğŸ”¹ Divide two integers without using multiplication, division and mod operator
### ğŸ”¸ Substep 2: Interview Problems
- ğŸ”¹ Count number of bits to be flipped to convert A to B
- ğŸ”¹ Find the number that appears odd number of times
- ğŸ”¹ Power Set
- ğŸ”¹ Find xor of numbers from L to R
- ğŸ”¹ Find the two numbers appearing odd number of times
### ğŸ”¸ Substep 3: Advanced Maths
- ğŸ”¹ Print Prime Factors of a Number
- ğŸ”¹ All Divisors of a Number
- ğŸ”¹ Sieve of Eratosthenes
- ğŸ”¹ Find Prime Factorisation of a Number using Sieve
- ğŸ”¹ Power(n, x)

---
## âœ… Step 9: Stack and Queues [Learning, Pre-In-Post-fix, Monotonic Stack, Implementation]
### ğŸ”¸ Substep 1: Learning
- ğŸ”¹ Implement Stack using Arrays
- ğŸ”¹ Implement Queue using Arrays
- ğŸ”¹ Implement Stack using Queue
- ğŸ”¹ Implement Queue using Stack
- ğŸ”¹ Implement stack using Linkedlist
- ğŸ”¹ Implement queue using Linkedlist
- ğŸ”¹ Check for balanced paranthesis
- ğŸ”¹ Implement Min Stack
### ğŸ”¸ Substep 2: Prefix, Infix, PostFix Conversion Problems
- ğŸ”¹ Infix to Postfix Conversion using Stack
- ğŸ”¹ Prefix to Infix Conversion
- ğŸ”¹ Prefix to Postfix Conversion
- ğŸ”¹ Postfix to Prefix Conversion
- ğŸ”¹ Postfix to Infix
- ğŸ”¹ Convert Infix To Prefix Notation
### ğŸ”¸ Substep 3: Monotonic Stack/Queue Problems [VVV. Imp]
- ğŸ”¹ Next Greater Element
- ğŸ”¹ Next Greater Element 2
- ğŸ”¹ Next Smaller Element
- ğŸ”¹ Number of NGEs to the right
- ğŸ”¹ Trapping Rainwater
- ğŸ”¹ Sum of subarray minimum
- ğŸ”¹ Asteroid Collision
- ğŸ”¹ Sum of subarray ranges
- ğŸ”¹ Remove k Digits
- ğŸ”¹ Largest rectangle in a histogram
- ğŸ”¹ Maximal Rectangles
### ğŸ”¸ Substep 4: Implementation Problems
- ğŸ”¹ Sliding Window maximum
- ğŸ”¹ Stock span problem
- ğŸ”¹ The Celebrity Problem
- ğŸ”¹ LRU cache (IMPORTANT)
- ğŸ”¹ LFU cache

---
## âœ… Step 10: Sliding Window & Two Pointer Combined Problems
### ğŸ”¸ Substep 1: Medium Problems
- ğŸ”¹ Longest Substring Without Repeating Characters
- ğŸ”¹ Max Consecutive Ones III
- ğŸ”¹ Fruit Into Baskets
- ğŸ”¹ longest repeating character replacement
- ğŸ”¹ Binary subarray with sum
- ğŸ”¹ Count number of nice subarrays
- ğŸ”¹ Number of substring containing all three characters
- ğŸ”¹ Maximum point you can obtain from cards
### ğŸ”¸ Substep 2: Hard Problems
- ğŸ”¹ Longest Substring with At Most K Distinct Characters
- ğŸ”¹ Subarray with k different integers
- ğŸ”¹ Minimum Window Substring
- ğŸ”¹ Minimum Window Subsequence

---
## âœ… Step 11: Heaps [Learning, Medium, Hard Problems]
### ğŸ”¸ Substep 1: Learning
- ğŸ”¹ Introduction to Priority Queues using Binary Heaps
- ğŸ”¹ Min Heap and Max Heap Implementation
- ğŸ”¹ Check if an array represents a min-heap or not
- ğŸ”¹ Convert min Heap to max Heap
### ğŸ”¸ Substep 2: Medium Problems
- ğŸ”¹ Kth largest element in an array [use priority queue]
- ğŸ”¹ Kth smallest element in an array [use priority queue]
- ğŸ”¹ Sort K sorted array
- ğŸ”¹ Merge M sorted Lists
- ğŸ”¹ Replace each array element by its corresponding rank
- ğŸ”¹ Task Scheduler
- ğŸ”¹ Hands of Straights
### ğŸ”¸ Substep 3: Hard Problems
- ğŸ”¹ Design twitter
- ğŸ”¹ Connect `n` ropes with minimal cost
- ğŸ”¹ Kth largest element in a stream of running integers
- ğŸ”¹ Maximum Sum Combination
- ğŸ”¹ Find Median from Data Stream
- ğŸ”¹ K most frequent elements

---
## âœ… Step 12: Greedy Algorithms [Easy, Medium/Hard]
### ğŸ”¸ Substep 1: Easy Problems
- ğŸ”¹ Assign Cookies
- ğŸ”¹ Fractional Knapsack Problem
- ğŸ”¹ Greedy algorithm to find minimum number of coins
- ğŸ”¹ Lemonade Change
- ğŸ”¹ Valid Paranthesis Checker
### ğŸ”¸ Substep 2: Medium/Hard
- ğŸ”¹ N meetings in one room
- ğŸ”¹ Jump Game
- ğŸ”¹ Jump Game 2
- ğŸ”¹ Minimum number of platforms required for a railway
- ğŸ”¹ Job sequencing Problem
- ğŸ”¹ Candy
- ğŸ”¹ Program for Shortest Job First (or SJF) CPU Scheduling
- ğŸ”¹ Program for Least Recently Used (LRU) Page Replacement Algorithm
- ğŸ”¹ Insert Interval
- ğŸ”¹ Merge Intervals
- ğŸ”¹ Non-overlapping Intervals

---
## âœ… Step 13: Binary Trees [Traversals, Medium and Hard Problems]
### ğŸ”¸ Substep 1: Traversals
- ğŸ”¹ Introduction to Trees
- ğŸ”¹ Binary Tree Representation in C++
- ğŸ”¹ Binary Tree Representation in Java
- ğŸ”¹ Binary Tree Traversals in Binary Tree
- ğŸ”¹ Preorder Traversal of Binary Tree
- ğŸ”¹ Inorder Traversal of Binary Tree
- ğŸ”¹ Post-order Traversal of Binary Tree
- ğŸ”¹ Level order Traversal / Level order traversal in spiral form
- ğŸ”¹ Iterative Preorder Traversal of Binary Tree
- ğŸ”¹ Iterative Inorder Traversal of Binary Tree
- ğŸ”¹ Post-order Traversal of Binary Tree using 2 stack
- ğŸ”¹ Post-order Traversal of Binary Tree using 1 stack
- ğŸ”¹ Preorder, Inorder, and Postorder Traversal in one Traversal
### ğŸ”¸ Substep 2: Medium Problems
- ğŸ”¹ Height of a Binary Tree
- ğŸ”¹ Check if the Binary tree is height-balanced or not
- ğŸ”¹ Diameter of Binary Tree
- ğŸ”¹ Maximum path sum
- ğŸ”¹ Check if two trees are identical or not
- ğŸ”¹ Zig Zag Traversal of Binary Tree
- ğŸ”¹ Boundary Traversal of Binary Tree
- ğŸ”¹ Vertical Order Traversal of Binary Tree
- ğŸ”¹ Top View of Binary Tree
- ğŸ”¹ Bottom View of Binary Tree
- ğŸ”¹ Right/Left View of Binary Tree
- ğŸ”¹ Symmetric Binary Tree
### ğŸ”¸ Substep 3: Hard Problems
- ğŸ”¹ Root to Node Path in Binary Tree
- ğŸ”¹ LCA in Binary Tree
- ğŸ”¹ Maximum width of a Binary Tree
- ğŸ”¹ Check for Children Sum Property
- ğŸ”¹ Print all the Nodes at a distance of K in a Binary Tree
- ğŸ”¹ Minimum time taken to BURN the Binary Tree from a Node
- ğŸ”¹ Count total Nodes in a COMPLETE Binary Tree
- ğŸ”¹ Requirements needed to construct a Unique Binary Tree | Theory
- ğŸ”¹ Construct Binary Tree from inorder and preorder
- ğŸ”¹ Construct the Binary Tree from Postorder and Inorder Traversal
- ğŸ”¹ Serialize and deserialize Binary Tree
- ğŸ”¹ Morris Preorder Traversal of a Binary Tree
- ğŸ”¹ Morris Inorder Traversal of a Binary Tree
- ğŸ”¹ Flatten Binary Tree to LinkedList

---
## âœ… Step 14: Binary Search Trees [Concept and Problems]
### ğŸ”¸ Substep 1: Concepts
- ğŸ”¹ Introduction to Binary Search Tree
- ğŸ”¹ Search in a Binary Search Tree
- ğŸ”¹ Find Min/Max in BST
### ğŸ”¸ Substep 2: Practice Problems
- ğŸ”¹ Ceil in a Binary Search Tree
- ğŸ”¹ Floor in a Binary Search Tree
- ğŸ”¹ Insert a given Node in Binary Search Tree
- ğŸ”¹ Delete a Node in Binary Search Tree
- ğŸ”¹ Find K-th smallest/largest element in BST
- ğŸ”¹ Check if a tree is a BST or BT
- ğŸ”¹ LCA in Binary Search Tree
- ğŸ”¹ Construct a BST from a preorder traversal
- ğŸ”¹ Inorder Successor/Predecessor in BST
- ğŸ”¹ Merge 2 BST's
- ğŸ”¹ Two Sum In BST | Check if there exists a pair with Sum K
- ğŸ”¹ Recover BST | Correct BST with two nodes swapped
- ğŸ”¹ Largest BST in Binary Tree

---
## âœ… Step 15: Graphs [Concepts & Problems]
### ğŸ”¸ Substep 1: Learning
- ğŸ”¹ Graph and Types
- ğŸ”¹ Graph Representation | C++
- ğŸ”¹ Graph Representation | Java
- ğŸ”¹ Connected Components | Logic Explanation
- ğŸ”¹ BFS
- ğŸ”¹ DFS
### ğŸ”¸ Substep 2: Problems on BFS/DFS
- ğŸ”¹ Number of provinces (leetcode)
- ğŸ”¹ Connected Components Problem in Matrix
- ğŸ”¹ Rotten Oranges
- ğŸ”¹ Flood fill
- ğŸ”¹ Cycle Detection in unirected Graph (bfs)
- ğŸ”¹ Cycle Detection in undirected Graph (dfs)
- ğŸ”¹ 0/1 Matrix (Bfs Problem)
- ğŸ”¹ Surrounded Regions (dfs)
- ğŸ”¹ Number of Enclaves [flood fill implementation - multisource]
- ğŸ”¹ Word ladder - 1
- ğŸ”¹ Word ladder - 2
- ğŸ”¹ Number of Distinct Islands [dfs multisource]
- ğŸ”¹ Bipartite Graph (DFS)
- ğŸ”¹ Cycle Detection in Directed Graph (DFS)
### ğŸ”¸ Substep 3: Topo Sort and Problems
- ğŸ”¹ Topo Sort
- ğŸ”¹ Kahn's Algorithm
- ğŸ”¹ Cycle Detection in Directed Graph (BFS)
- ğŸ”¹ Course Schedule - I
- ğŸ”¹ Course Schedule - II
- ğŸ”¹ Find eventual safe states
- ğŸ”¹ Alien dictionary
### ğŸ”¸ Substep 4: Shortest Path Algorithms and Problems
- ğŸ”¹ Shortest Path in UG with unit weights
- ğŸ”¹ Shortest Path in DAG
- ğŸ”¹ Djisktra's Algorithm
- ğŸ”¹ Why priority Queue is used in Djisktra's Algorithm
- ğŸ”¹ Shortest path in a binary maze
- ğŸ”¹ Path with minimum effort
- ğŸ”¹ Cheapest flights within k stops
- ğŸ”¹ Network Delay time
- ğŸ”¹ Number of ways to arrive at destination
- ğŸ”¹ Minimum steps to reach end from start by performing multiplication and mod operations with array elements
- ğŸ”¹ Bellman Ford Algorithm
- ğŸ”¹ Floyd Warshal Algorithm
- ğŸ”¹ Find the city with the smallest number of neighbors in a threshold distance
### ğŸ”¸ Substep 5: MinimumSpanningTree/Disjoint Set and Problems
- ğŸ”¹ Minimum Spanning Tree
- ğŸ”¹ Prim's Algorithm
- ğŸ”¹ Disjoint Set [Union by Rank]
- ğŸ”¹ Disjoint Set [Union by Size]
- ğŸ”¹ Kruskal's Algorithm
- ğŸ”¹ Number of operations to make network connected
- ğŸ”¹ Most stones removed with same rows or columns
- ğŸ”¹ Accounts merge
- ğŸ”¹ Number of island II
- ğŸ”¹ Making a Large Island
- ğŸ”¹ Swim in rising water
### ğŸ”¸ Substep 6: Other Algorithms
- ğŸ”¹ Bridges in Graph
- ğŸ”¹ Articulation Point
- ğŸ”¹ Kosaraju's Algorithm

---
## âœ… Step 16: Dynamic Programming [Patterns and Problems]
### ğŸ”¸ Substep 1: Introduction to DP
- ğŸ”¹ Dynamic Programming Introduction
### ğŸ”¸ Substep 2: 1D DP
- ğŸ”¹ Climbing Stars
- ğŸ”¹ Frog Jump(DP-3)
- ğŸ”¹ Frog Jump with k distances(DP-4)
- ğŸ”¹ Maximum sum of non-adjacent elements (DP 5)
- ğŸ”¹ House Robber (DP 6)
### ğŸ”¸ Substep 3: 2D/3D DP and DP on Grids
- ğŸ”¹ Ninja's Training (DP 7)
- ğŸ”¹ Grid Unique Paths : DP on Grids (DP8)
- ğŸ”¹ Grid Unique Paths 2 (DP 9)
- ğŸ”¹ Minimum path sum in Grid (DP 10)
- ğŸ”¹ Minimum path sum in Triangular Grid (DP 11)
- ğŸ”¹ Minimum/Maximum Falling Path Sum (DP-12)
- ğŸ”¹ 3-d DP : Ninja and his friends (DP-13)
### ğŸ”¸ Substep 4: DP on Subsequences
- ğŸ”¹ Subset sum equal to target (DP- 14)
- ğŸ”¹ Partition Equal Subset Sum (DP- 15)
- ğŸ”¹ Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP- 16)
- ğŸ”¹ Count Subsets with Sum K (DP - 17)
- ğŸ”¹ Count Partitions with Given Difference (DP - 18)
- ğŸ”¹ Assign Cookies
- ğŸ”¹ Minimum Coins (DP - 20)
- ğŸ”¹ Target Sum (DP - 21)
- ğŸ”¹ Coin Change 2 (DP - 22)
- ğŸ”¹ Unbounded Knapsack (DP - 23)
- ğŸ”¹ Rod Cutting Problem | (DP - 24)
### ğŸ”¸ Substep 5: DP on Strings
- ğŸ”¹ Longest Common Subsequence | (DP - 25)
- ğŸ”¹ Print Longest Common Subsequence | (DP - 26)
- ğŸ”¹ Longest Common Substring | (DP - 27)
- ğŸ”¹ Longest Palindromic Subsequence | (DP-28)
- ğŸ”¹ Minimum insertions to make string palindrome | DP-29
- ğŸ”¹ Minimum Insertions/Deletions to Convert String | (DP- 30)
- ğŸ”¹ Shortest Common Supersequence | (DP - 31)
- ğŸ”¹ Distinct Subsequences| (DP-32)
- ğŸ”¹ Edit Distance | (DP-33)
- ğŸ”¹ Wildcard Matching | (DP-34)
### ğŸ”¸ Substep 6: DP on Stocks
- ğŸ”¹ Best Time to Buy and Sell Stock |(DP-35)
- ğŸ”¹ Buy and Sell Stock - II|(DP-36)
- ğŸ”¹ Buy and Sell Stocks III|(DP-37)
- ğŸ”¹ Buy and Stock Sell IV |(DP-38)
- ğŸ”¹ Buy and Sell Stocks With Cooldown|(DP-39)
- ğŸ”¹ Buy and Sell Stocks With Transaction Fee|(DP-40)
### ğŸ”¸ Substep 7: DP on LIS
- ğŸ”¹ Longest Increasing Subsequence |(DP-41)
- ğŸ”¹ Printing Longest Increasing Subsequence|(DP-42)
- ğŸ”¹ Longest Increasing Subsequence |(DP-43)
- ğŸ”¹ Largest Divisible Subset|(DP-44)
- ğŸ”¹ Longest String Chain|(DP-45)
- ğŸ”¹ Longest Bitonic Subsequence |(DP-46)
- ğŸ”¹ Number of Longest Increasing Subsequences|(DP-47)
### ğŸ”¸ Substep 8: MCM DP | Partition DP
- ğŸ”¹ Matrix Chain Multiplication|(DP-48)
- ğŸ”¹ Matrix Chain Multiplication | Bottom-Up|(DP-49)
- ğŸ”¹ Minimum Cost to Cut the Stick|(DP-50)
- ğŸ”¹ Burst Balloons|(DP-51)
- ğŸ”¹ Evaluate Boolean Expression to True|(DP-52)
- ğŸ”¹ Palindrome Partitioning - II|(DP-53)
- ğŸ”¹ Partition Array for Maximum Sum|(DP-54)
### ğŸ”¸ Substep 9: DP on Squares
- ğŸ”¹ Maximum Rectangle Area with all 1's|(DP-55)
- ğŸ”¹ Count Square Submatrices with All Ones|(DP-56)

---
## âœ… Step 17: Tries
### ğŸ”¸ Substep 1: Theory
- ğŸ”¹ Implement TRIE | INSERT | SEARCH | STARTSWITH
### ğŸ”¸ Substep 2: Problems
- ğŸ”¹ Implement Trie - 2 (Prefix Tree)
- ğŸ”¹ Longest String with All Prefixes
- ğŸ”¹ Number of Distinct Substrings in a String
- ğŸ”¹ Bit PreRequisites for TRIE Problems
- ğŸ”¹ Maximum XOR of two numbers in an array
- ğŸ”¹ Maximum XOR With an Element From Array

---
## âœ… Step 18: Strings
### ğŸ”¸ Substep 1: Hard Problems
- ğŸ”¹ Minimum number of bracket reversals needed to make an expression balanced
- ğŸ”¹ Count and say
- ğŸ”¹ Hashing In Strings | Theory
- ğŸ”¹ Rabin Karp
- ğŸ”¹ Z-Function
- ğŸ”¹ KMP algo / LPS(pi) array
- ğŸ”¹ Shortest Palindrome
- ğŸ”¹ Longest happy prefix
- ğŸ”¹ Count palindromic subsequence in given string

---
